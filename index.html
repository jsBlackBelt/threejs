<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
        <title>Basic Three.js App</title>
        <style>
          html, body { margin: 0; padding: 0; overflow: hidden; }
        </style>
	</head>
	<body>
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
		<script>
            // Our Javascript will go here.
            const scene = new THREE.Scene();
            const color = new THREE.Color("rgb(255, 255, 255)");
            scene.background = color;

            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            camera.position.set(0, 0, 60);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            const cubeGeometry = new THREE.BoxGeometry( 10, 10, 10 );
            const cubeMaterial = new THREE.MeshNormalMaterial();

            const cube1 = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cube1.position.x = -60;
            cube1.userData.clickHandler = () => console.log('cube 1');
            scene.add( cube1 );

            const cube1Label = makeTextSprite(' Cube 1 ', { fontsize: 24 } );
            cube1Label.position.set(0, -5.5, 0);
	        cube1.add( cube1Label );

            const cube2 = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cube2.position.x = 60;
            cube2.userData.clickHandler = () => console.log('cube 2');
            scene.add( cube2 );

            const cube2Label = makeTextSprite(' Cube 2 ', { fontsize: 24 } );
            cube2Label.position.set(0, -5.5, 0);
	        cube2.add( cube2Label );

            const lineMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
            const lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push(cube1.position);
            lineGeometry.vertices.push(cube2.position);
            const line = new THREE.Line( lineGeometry, lineMaterial );
            scene.add(line);

            camera.position.set(-90, 30, 90);
            camera.lookAt(scene.position);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.update();

            const axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );

            // interactivity
            const mouse = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();
            const targetList = [cube1, cube2];
            // on mouse down, call the given function
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );

            function onDocumentMouseDown( event ) {
                // the following line would stop any other event handler from firing
                // (such as the mouse's TrackballControls)
                // event.preventDefault();

                // update the mouse variable
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y =  - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                // find intersections

                // create a Ray with origin at the mouse position
                //   and direction into the scene (camera direction)
                raycaster.setFromCamera(mouse, camera);

                // create an array containing all objects in the scene with which the ray intersects
                const intersects = raycaster.intersectObjects( targetList );

                // if there is one (or more) intersections
                if ( intersects.length > 0 ) {
                    intersects[ 0 ].object.userData.clickHandler();
                }

            }

            function makeTextSprite( message, parameters ) {
                if ( parameters === undefined ) parameters = {};

                var fontface = parameters.hasOwnProperty("fontface") ?
                    parameters["fontface"] : "Arial";

                var fontsize = parameters.hasOwnProperty("fontsize") ?
                    parameters["fontsize"] : 18;

                var borderThickness = parameters.hasOwnProperty("borderThickness") ?
                    parameters["borderThickness"] : 4;

                var canvas = document.createElement('canvas');
                var context = canvas.getContext('2d');
                context.font = "Bold " + fontsize + "px " + fontface;

                // get size data (height depends only on font size)
                var metrics = context.measureText( message );
                var textWidth = metrics.width;

                context.lineWidth = borderThickness;
                // roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
                // 1.4 is extra height factor for text below baseline: g,j,p,q.

                // text color
                context.fillStyle = "rgba(0, 0, 0, 1.0)";

                context.fillText( message, borderThickness, fontsize + borderThickness);

                // canvas contents will be used for a texture
                var texture = new THREE.Texture(canvas)
                texture.needsUpdate = true;

                var spriteMaterial = new THREE.SpriteMaterial(
                    { map: texture, useScreenCoordinates: false } );
                var sprite = new THREE.Sprite( spriteMaterial );
                sprite.scale.set(100,50,1.0);
                return sprite;
            }

            function animate() {
                requestAnimationFrame( animate );
                controls.update();

                renderer.render( scene, camera );
            }
            animate();


		</script>
	</body>
</html>
